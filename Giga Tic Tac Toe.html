<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Giga Tic Tac Toe</title>

  <!-- Orbitron font -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --size: 81;
      --mini: 9;
      --cell: 20px;
      --thin: 1px;
      --thick: 3px;
      --gridColor: #fff;
      --thickColor: #000064;
      --accent: #fff;
      --allowX: rgba(0, 255, 255, 1);
      --allowO: rgba(255, 0, 0, 1);
      --wonX: rgba(0, 255, 255, 1);
      --wonO: rgba(255, 0, 0, 1);
      --forbidden: 0;
    }

    * { box-sizing: border-box; }
    body {
      margin: 16px;
      font-family: 'Orbitron', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #000064;
      color: #ffffff;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 50px;
      font-weight: 2000;
      letter-spacing: .5px;
    }
    h2 {
      margin: 0 0 16px;
      font-size: 30px;
      font-weight: 600;
      opacity: .8;
    }

    .topbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    .btn {
      font-family: 'Orbitron', sans-serif;
      border: 1px solid #ffffff;
      background: #000064;
      color: #ffffff;
      padding: 8px 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select: none;
    }
    .btn:hover { background: #000064; border-color: #ffffff; }
    .btn:active { transform: translateY(1px); }

    .info {
      margin-left: auto;
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 13px;
      opacity: .9;
    }
    .tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #ffffff;
      background: #000064;
    }

    #boardWrap {
      overflow: auto;
      border: 1px solid #ffffff;
      border-radius: 16px;
      background: #000064;
      padding: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
      max-height: 78vh;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(81, var(--cell));
      grid-template-rows: repeat(81, var(--cell));
      transform: scale(1);
      transform-origin: top left;
      transition: transform 0.15s ease;
      /* We’ll rely on borders for separators; no grid gap */
    }

    .cell {
      width: var(--cell);
      height: var(--cell);
      border: var(--thin) solid var(--gridColor);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      color: #e9eef5;
    }
    .cell.X { color: #00ffff; font-weight: 1000; }
    .cell.O { color: #ff0000; font-weight: 1000; }

    /* Thicker borders to form 9×9 mini-boards */
    .cell[data-col="0"]       { border-left: var(--thick) solid var(--thickColor); }
    .cell[data-col-9="true"]  { border-left: var(--thick) solid var(--thickColor); }
    .cell[data-row="0"]       { border-top: var(--thick) solid var(--thickColor); }
    .cell[data-row-9="true"]  { border-top: var(--thick) solid var(--thickColor); }

    /* Right and bottom thick edges of the whole board */
    .cell[data-col="80"] { border-right: var(--thick) solid var(--thickColor); }
    .cell[data-row="80"] { border-bottom: var(--thick) solid var(--thickColor); }

    /* Allowed / forbidden cues */
    .cell.forbidden {
      opacity: var(--forbidden);
      cursor: not-allowed;
    }
    .cell.allowed {
      background: var(--allow);
      outline: 1px solid rgba(255,255,255,0.25);
      outline-offset: -1px;
    }

    /* Mini-board win shading */
    .cell.wonX { background: var(--wonX); }
    .cell.wonO { background: var(--wonO); }

    /* Status line */
    .status {
      margin: 10px 0 8px;
      font-size: 14px;
    }
    .status strong { color: #ffffff; }

    /* Zoom hint */
    .hint { font-size: 12px; opacity: .7; }
  </style>
</head>
<body>
  <h1>Giga Tic Tac Toe</h1>
  <h2>A Game of Strategy.</h2>

  <div class="topbar">
    <button class="btn" id="newGameBtn">New Game</button>
    <button class="btn" id="zoomInBtn">Zoom In</button>
    <button class="btn" id="zoomOutBtn">Zoom Out</button>
    <button class="btn" id="resetZoomBtn">Reset Zoom</button>
    <div class="info">
      <span class="tag">Mini win: 9-in-a-row</span>
      <span class="tag">Game win: 9 mini-boards in a row</span>
    </div>
  </div>

  <div class="status" id="status">Current: <strong>X</strong> — play in highlighted mini-board.</div>
  <div class="hint">Tip: your move’s (row%9, col%9) selects the opponent’s next mini-board. If that mini-board is won/full, they can play anywhere.</div>

  <div id="boardWrap">
    <div id="board" aria-label="81 by 81 Ultimate Tic Tac Toe board"></div>
  </div>

  <script>
    // --- Config ---
    const SIZE = 81;      // board cells per side
    const MINI = 9;       // mini-board cells per side
    const MINI_COUNT = SIZE / MINI; // 27
    const IN_A_ROW_MINI = 9;  // to win a 9×9 mini-board
    const IN_A_ROW_MEGA = 9;  // to win the overall 9×9 grid of mini-boards

    // --- State ---
    let board = []; // '','X','O'
    let current = 'X';
    let forced = null; // {r:0..8, c:0..8} or null (anywhere)
    let miniWinners = []; // 9×9 of '', 'X','O','T'
    let zoomLevel = 1;
    let gameOver = false;

    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');

    // Initialize arrays
    function initState() {
      board = Array(SIZE * SIZE).fill('');
      miniWinners = Array.from({ length: MINI_COUNT }, () => Array(MINI_COUNT).fill(''));
      current = 'X';
      forced = null;
      gameOver = false;
      zoomLevel = 1;
      boardEl.style.transform = 'scale(1)';
      setStatusCurrent();
    }

    // Helpers to map index/coords
    function idx(r, c) { return r * SIZE + c; }
    function inBounds(r, c) { return r >= 0 && r < SIZE && c >= 0 && c < SIZE; }

    function cellMiniRC(r, c) {
      return { mr: Math.floor(r / MINI), mc: Math.floor(c / MINI) };
    }
    function nextForcedFrom(r, c) {
      return { r: r % MINI, c: c % MINI };
    }

    function miniIsPlayable(mr, mc) {
      const w = miniWinners[mr][mc];
      if (w) return false; // won or tie
      // also check if at least one empty cell exists
      for (let rr = mr * MINI; rr < (mr + 1) * MINI; rr++) {
        for (let cc = mc * MINI; cc < (mc + 1) * MINI; cc++) {
          if (board[idx(rr, cc)] === '') return true;
        }
      }
      return false;
    }

    function miniIsFull(mr, mc) {
      for (let rr = mr * MINI; rr < (mr + 1) * MINI; rr++) {
        for (let cc = mc * MINI; cc < (mc + 1) * MINI; cc++) {
          if (board[idx(rr, cc)] === '') return false;
        }
      }
      return true;
    }

    // Check 5-in-a-row in a 9×9 mini board around (r,c)
    function checkMiniWin(r, c, player) {
      const { mr, mc } = cellMiniRC(r, c);
      const r0 = mr * MINI, c0 = mc * MINI;

      // 4 directions: (dr,dc)
      const dirs = [
        [1, 0],  // vertical
        [0, 1],  // horizontal
        [1, 1],  // diag down-right
        [1, -1], // diag down-left
      ];

      for (const [dr, dc] of dirs) {
        let count = 1;

        // forward
        let rr = r + dr, cc = c + dc;
        while (rr >= r0 && rr < r0 + MINI && cc >= c0 && cc < c0 + MINI && board[idx(rr, cc)] === player) {
          count++; rr += dr; cc += dc;
        }
        // backward
        rr = r - dr; cc = c - dc;
        while (rr >= r0 && rr < r0 + MINI && cc >= c0 && cc < c0 + MINI && board[idx(rr, cc)] === player) {
          count++; rr -= dr; cc -= dc;
        }

        if (count >= IN_A_ROW_MINI) return true;
      }
      return false;
    }

    // Check 3 in a row on the 9×9 grid of mini winners
    function checkGameWin(player) {
      const N = MINI_COUNT; // 9
      // Horizontal / Vertical
      for (let r = 0; r < N; r++) {
        for (let c = 0; c <= N - IN_A_ROW_MEGA; c++) {
          if (miniWinners[r][c] === player &&
              miniWinners[r][c + 1] === player &&
              miniWinners[r][c + 2] === player) return true;
        }
      }
      for (let c = 0; c < N; c++) {
        for (let r = 0; r <= N - IN_A_ROW_MEGA; r++) {
          if (miniWinners[r][c] === player &&
              miniWinners[r + 1][c] === player &&
              miniWinners[r + 2][c] === player) return true;
        }
      }
      // Diagonals
      for (let r = 0; r <= N - IN_A_ROW_MEGA; r++) {
        for (let c = 0; c <= N - IN_A_ROW_MEGA; c++) {
          if (miniWinners[r][c] === player &&
              miniWinners[r + 1][c + 1] === player &&
              miniWinners[r + 2][c + 2] === player) return true;
          if (miniWinners[r][c + 2] === player &&
              miniWinners[r + 1][c + 1] === player &&
              miniWinners[r + 2][c] === player) return true;
        }
      }
      return false;
    }

    // Build DOM
    function buildBoard() {
      boardEl.innerHTML = '';
      const frag = document.createDocumentFragment();

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const d = document.createElement('div');
          d.className = 'cell';
          d.dataset.row = String(r);
          d.dataset.col = String(c);
          if (c % MINI === 0 && c !== 0) d.setAttribute('data-col-9', 'true');
          if (r % MINI === 0 && r !== 0) d.setAttribute('data-row-9', 'true');

          d.addEventListener('click', () => onCellClick(r, c, d));
          frag.appendChild(d);
        }
      }
      boardEl.appendChild(frag);
    }

    // Highlight allowed region(s)
    function refreshHighlights() {
      const cells = boardEl.children;
      for (let i = 0; i < cells.length; i++) {
        const d = cells[i];
        d.classList.remove('allowed', 'forbidden', 'wonX', 'wonO');
      }

      // Mark won mini-boards with soft shading
      for (let mr = 0; mr < MINI_COUNT; mr++) {
        for (let mc = 0; mc < MINI_COUNT; mc++) {
          if (!miniWinners[mr][mc]) continue;
          const cls = miniWinners[mr][mc] === 'X' ? 'wonX' :
                      miniWinners[mr][mc] === 'O' ? 'wonO' : '';
          if (!cls) continue;
          for (let rr = mr * MINI; rr < (mr + 1) * MINI; rr++) {
            for (let cc = mc * MINI; cc < (mc + 1) * MINI; cc++) {
              boardEl.children[idx(rr, cc)].classList.add(cls);
            }
          }
        }
      }

      if (gameOver) return;

      // Determine which mini-boards are playable
      let playableBoards = [];
      if (forced && miniIsPlayable(forced.r, forced.c)) {
        playableBoards = [forced];
      } else {
        // Anywhere (any playable mini-board)
        for (let mr = 0; mr < MINI_COUNT; mr++) {
          for (let mc = 0; mc < MINI_COUNT; mc++) {
            if (miniIsPlayable(mr, mc)) playableBoards.push({ r: mr, c: mc });
          }
        }
      }

      // Mark allowed cells and dim the rest
      const allowedMask = Array(SIZE * SIZE).fill(false);
      for (const { r: mr, c: mc } of playableBoards) {
        for (let rr = mr * MINI; rr < (mr + 1) * MINI; rr++) {
          for (let cc = mc * MINI; cc < (mc + 1) * MINI; cc++) {
            const i = idx(rr, cc);
            if (board[i] === '') allowedMask[i] = true;
          }
        }
      }

      for (let i = 0; i < board.length; i++) {
        const d = boardEl.children[i];
        const mark = board[i];
        if (mark === '') {
          if (allowedMask[i]) d.classList.add('allowed');
          else d.classList.add('forbidden');
        } else {
          d.classList.remove('allowed', 'forbidden');
        }
      }
    }

    function updateCellDisplay(r, c) {
      const i = idx(r, c);
      const d = boardEl.children[i];
      if (board[i] === 'X') {
        d.textContent = 'X';
      } else if (board[i] === 'O') {
        d.textContent = 'X';
      } else {
        d.textContent = '';
      }
      d.classList.toggle('X', board[i] === 'X');
      d.classList.toggle('O', board[i] === 'O');
    }

    function concludeMiniIfNeeded(mr, mc) {
      if (miniWinners[mr][mc]) return; // already set
      if (miniIsFull(mr, mc)) {
        // If full but no 5-in-a-row winner, mark tie
        miniWinners[mr][mc] = 'T';
      }
    }

    // Update status display to use emojis
    function setStatusCurrent() {
      const emoji = current === 'X' ? 'X' : 'O';
      statusEl.innerHTML = `Current: <strong>${emoji}</strong>${forced ? ` — play in mini-board (${forced.r + 1}, ${forced.c + 1})` : ' — play anywhere'}.`;
    }

    // Update winner display to use emojis
    function setStatusWinner(winner) {
      const emoji = winner === 'X' ? 'X' : 'O';
      statusEl.innerHTML = `Winner: <strong>${emoji}</strong> — game over!`;
    }

    function onCellClick(r, c, dEl) {
      if (gameOver) return;
      const i = idx(r, c);
      if (board[i] !== '') return;

      const { mr, mc } = cellMiniRC(r, c);

      // Enforce forced mini-board, unless it's unplayable
      if (forced && !(mr === forced.r && mc === forced.c) && miniIsPlayable(forced.r, forced.c)) {
        return; // not allowed
      }

      // Place move
      board[i] = current;
      updateCellDisplay(r, c);

      // Mini-board win check
      let miniJustWon = false;
      if (checkMiniWin(r, c, current)) {
        miniWinners[mr][mc] = current;
        miniJustWon = true;
      } else {
        concludeMiniIfNeeded(mr, mc);
      }

      // Game win?
      if (miniJustWon && checkGameWin(current)) {
        gameOver = true;
        setStatusWinner(current);
        refreshHighlights();
        return;
      }

      // Next forced mini-board
      const nf = nextForcedFrom(r, c);
      if (miniIsPlayable(nf.r, nf.c)) {
        forced = nf;
      } else {
        forced = null; // anywhere
      }

      // Switch player
      current = current === 'X' ? 'O' : 'X';
      setStatusCurrent();
      refreshHighlights();
    }

    // Zoom controls
    function zoomIn()  { zoomLevel = Math.min(4, zoomLevel + 0.1); boardEl.style.transform = `scale(${zoomLevel})`; }
    function zoomOut() { zoomLevel = Math.max(0.1, zoomLevel - 0.1); boardEl.style.transform = `scale(${zoomLevel})`; }
    function resetZoom(){ zoomLevel = 1; boardEl.style.transform = 'scale(1)'; }

    // New game
    function newGame() {
      initState();
      // Clear DOM cell content/classes
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const d = boardEl.children[idx(r, c)];
          d.textContent = '';
          d.classList.remove('X', 'O', 'allowed', 'forbidden', 'wonX', 'wonO');
        }
      }
      setStatusCurrent();
      refreshHighlights();
    }

    // Wire buttons
    document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
    document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
    document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
    document.getElementById('newGameBtn').addEventListener('click', newGame);

    // Boot
    (function start() {
      initState();
      buildBoard();
      refreshHighlights();
    })();
  </script>
</body>
</html>
